# [9. Palindrome Number](https://leetcode.com/problems/palindrome-number/)

Given an integer x, return true if x is a palindrome , and false otherwise.

---
### Example 1:
>Input: x = 121 <p>
>Output: true <p>
>Explanation: 121 reads as 121 from left to right and from right to left. <p>
### Example 2:
>Input: x = -121<p>
>Output: false<p>
>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.<p>
### Example 3:
>Input: x = 10<p>
>Output: false<p>
>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.<p>

___
### Constraints:
>-231 <= x <= 231 - 1<p>

***Follow up: Could you solve it without converting the integer to a string?***

---
### Faq
Число-палиндром - это число, которое читается одинаково слева направо и справа налево, <p> 
то есть симметричное число. Например, 292 или 5335. <p>
Задание: Написать код, который проверяет, является ли входящее число палиндромом (т.е. симметричным), <p>
и выводит в консоль "Да", если является, и "Нет", если не является. <p>
Существуют разные подходы к решению этой задачи. <p>
Например, можно превратить входящее число в строку <p> 
и начать посимвольное сравнение с обоих концов массива, двигаясь к середине. <p> 
Если дойдя до середины строки все символы по пути совпали, значит строка является палиндромом. <p>
Данное решение имеет недостаток, который заключается в выделении памяти под строку, <p> 
с которой мы будем работать. <p> 
В идеале задача должна быть решена с применением постоянного дополнительного пространства (constant extra space), <p>
т.е. все дополнительные структуры данных, которые мы выделяем для решения задачи, <p>
не должны зависеть от размера входящих данных (т.е. иметь скорость O(1)). <p>
Решая задачу этим путём, память под строку выделяется линейно (O(n)), <p>
то есть чем больше строка, тем больше под неё будет выделено памяти. <p>
Следующий вариант - это инвертировать число и сравнить его со входящим. <p>
Если оба числа одинаковые, значит это число-палиндром. <p>
Этот вариант тоже имеет подводные камни. <p>
Во-первых, при больших значениях входящего числа может выйти так, <p>
что когда мы инвертируем входящее число, оно выйдет за пределы диапазона int. <p>
Например, было 2_147_483_647, стало 7_463_847_412 - данное число выходит из диапазона, <p>
которое может содержать тип int. Во-вторых, палиндром - это симметричное число. <p>
Для определения палиндрома достаточно инвертировать только половину числа и сравнить её со второй. <p>
Например: число 5335. Инвертируем вторую половину (35 в 53) и сравниваем с первой половиной (53 = 53). <p>
Полная инверсия числа является лишней тратой времени и ресурсов и ведёт к снижению производительности.
Итак, разобрав самые очевидные решения этой задачи и их недостатки, мы пришли к выводу, <p>
что наиболее оптимальным вариантом решения является инверсия одной половины числа и сравнение её со второй, <p>
а также выделение постоянного дополнительного пространства вместо непостоянного. <p>
Постарайтесь решить упражнение самостоятельно. Если не получится, то можно воспользоваться подсказками по реализации данного алгоритма: <p>
- Основная задача здесь - это отделить вторую половину числа. <p>
- Здесь нам помогут операторы % и /. <p>
- С помощью выражения number % 10 мы можем вычленить последнюю цифру любого числа, <p>
- а с помощью выражения number / 10 мы можем "обрезать" последнюю цифру, <p>
- которую мы только что вычленили с помощью оператора %.
- Под хранение значения инвертированной второй половины числа нужно выделить дополнительную переменную. <p>
- Она здесь и будет являться постоянным дополнительным пространством. <p>
- Постоянным, потому что независимо от размера входящего числа, мы будем перезаписывать одну и ту же переменную. <p>
- Далее нужно в цикле отделять последнее число и перезаписывать доп. <p>
- переменную, после чего обрезать последнюю цифру в числе и повторять цикл, <p>
- пока не дойдем до середины числа. Обратите внимание, <p>
- что так как мы каждый раз обрезаем последнее число делением на 10, <p>
- то перед его прибавлением к результату мы должны число, сохраненное в доп. <p>
- переменной, умножить на 10. Например: Из 5335 вычленили 5, осталось 533. <p>
- Формула прибавки: 10 * 0 (стартовое значение переменной) + 5 = 5. <p>
- На следующем шаге вычленяем 3, а формула прибавки будет 10 * 5 + 3 = 53. <p>
- Повторять в цикле до достижения середины числа.
- Середина определяется просто: пока входящее число (которое обрезаем на каждом шаге) остаётся больше, <p>
- чем то, которое мы составляем, значит середина еще не достигнута. <p>
- Помните, что количество цифр входящего числа может быть четным и нечетным, <p>
- поэтому получившая половина и половина, которая осталась, могут быть не равными. <p>
- Для этого достаточно в финальном сравнении предусмотреть вариант того, <p>
- что в инвертированную половину может быть записано и центральное число, <p>
- которое можно не учитывать, так как оно само по себе палиндром, так как находится в центре. <p>
- Это число можно исключить, добавив помимо сравнения с результатом доп. переменной еще и сравнение с результатом доп. <p>
- переменной, поделенной на 10, чтобы отсечь центральное число, и сделать подходящим первый или второй вариант. <p>